React Router is a popular react library for client-side routing.

Q. What is client-side routing?
Gonna learn:
1. Routing Basics
2. Navigation
3. Layout and Index routes
4. Nested routes
5. Route and Search Parameters
6. Protected routes

Q. Difference between MPA and SPA?
Ans: A Multi-Page Application renders different page content based on url change. The client (i.e. the browser) requests that page from the server and after processing the request, the server send back the response in the form of a html file which is then displayed by the browser.
In case of SPA, the client also makes a request to the server based on domain, the server instead of processing and sending the response in the form of html file, returns the entire react app, which is then processed on the client side to display the specific content. Meanwhile, this doesn't mean that the client can't make any further request to the server, it can but now for some kind of data that needs to be consumed into the react app, like json data and so on. In case of SPAs, the content is changed in the same page, we are not reloading the entire document.


BrowserRouter is the context Provider and in order to provide the routing functionalities we need to wrap the entire app in browser router. It provides the context to all of its child components.
Routes is the first child that goes inside BrowserRouter where we define Route components which in-tuen defines the content to be displayed on url change.

We often get fed up by changing the url manually(also refreshes the page each time) so here comes the Link component which acts like an anchor tag, clicking on which changes the page URL. It doesn't refreshes the page, so no state will be lost.
Link component will render the anchor tag in the DOM so use it carefully while applying css.

useParams:
allows use to grab any of the parameter that we have in the url

Q. What is a route/url parameter?
Ans: A portion of our route path that is a placeholder for what will eventually be the actual content in the URL of the page.

In the layout components we are putting the shared interface.

Nested Routes:
-> Nested URL
    1. /van
    2. /van/van-id-or-name
-> Shared UI
    Often parts of the page are shared within the same route
Usage: <Route>
          <Route>....<Route>
        </Route>
1. When you want to keep displaying some UI on the page, but also want to display more.
2. When you want to avoid repetition in your route definitions.

Relative Routes:
we have been using repetitive names in paths(absolute paths) like:
<Route path = '/host' element={....}>
    <Route path='/host/income' element={...} />
    <Route path='/host/reviews' element={...} />
</Route>
To avoid repetitiveness we will use Nested Routes.

Index Routes:
We use index instead of using path and this tells that we wanna render a page based on the layout url.

Q. What is the primary reason to use a nested route?
Ans: Whenever we have shared UI between routes in our app.

Q. What is a 'Layout Route'?
Ans: It's the parent route of some nested routes that contain just the portion of the UI that will be shared. It will use an Outlet component.

Q. What does the 'Outlet' component do? When do you use it?
Ans: We use it anytime we have a parent Route that's wrapping children routes. It renders the matching child route's 'element' prop given in it's route definition.

Q. What is an 'Index Route'?
Ans: It's the 'default route' we want to render when the path of the parent route matches. It gives us a chance to render an element inside the parent's <Outlet /> at the same path as the parent route.

****NOTE:*****
We can write the Route without using path or element or both prop(s).


NavLink allows us to add className and which can take up a callback function and inline style prop.
Here we want whatever link is active on the host page we gonna style them. Passing a callback receives an object with the .isActive key and we are gonna use that in HostLayout component. NavLink gives us the ability to know the 'active' status and style it accordingly.

Use of Relative Links/paths over Absolute links/paths:
In case of relative links, if I change the link name then I don't need to change at every place that is nested inside the parent link/path but in case of absolute link/path I need to change all the paths manually everywhere.

